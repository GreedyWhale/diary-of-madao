---
import FullScreenCanvas from "~/layouts/FullScreenCanvas.astro";
---

<FullScreenCanvas />

<script>
  import * as THREE from "three";
  import { OrbitControls } from "three/addons/controls/OrbitControls.js";

  import colorTexture from "/static/textures/door/Door_Wood_001_basecolor.jpg?url";

  const root = document.querySelector(".app")!;
  const canvas = document.createElement("canvas");
  root.appendChild(canvas);

  const sizes = {
    width: window.innerWidth,
    height: window.innerHeight,
  };

  let scene: THREE.Scene;
  let camera: THREE.PerspectiveCamera;
  let renderer: THREE.WebGLRenderer;
  let cube: THREE.Mesh<THREE.BoxGeometry, THREE.MeshBasicMaterial>;
  let sphere: THREE.Mesh<THREE.SphereGeometry, THREE.MeshBasicMaterial>;
  let cylinder: THREE.Mesh<THREE.CylinderGeometry, THREE.MeshBasicMaterial>;
  let texture: THREE.Texture;
  let control: OrbitControls;

  const initCamera = () => {
    camera = new THREE.PerspectiveCamera(75, sizes.width / sizes.height);
    camera.position.z = 5;
  };

  const initTexture = () => {
    const image = new Image();
    image.onload = () => {
      texture.needsUpdate = true;
    };

    texture = new THREE.Texture(image);
    image.src = colorTexture;
  };

  const initMesh = () => {
    const material = new THREE.MeshBasicMaterial({ map: texture });
    cube = new THREE.Mesh(new THREE.BoxGeometry(1, 1.5, 1), material);

    sphere = new THREE.Mesh(new THREE.SphereGeometry(1), material);

    cylinder = new THREE.Mesh(new THREE.CylinderGeometry(1, 1), material);

    sphere.position.x = -2;
    cylinder.position.x = 2;
  };

  const initScene = () => {
    scene = new THREE.Scene();
    scene.add(camera, cube, sphere, cylinder);
  };

  const initRenderer = () => {
    renderer = new THREE.WebGLRenderer({ canvas });
    renderer.setSize(sizes.width, sizes.height);
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    renderer.render(scene, camera);
  };

  const initControl = () => {
    control = new OrbitControls(camera, renderer.domElement);
    control.enableDamping = true;
    control.update();
  };

  const bindListeners = () => {
    window.addEventListener("resize", () => {
      sizes.width = window.innerWidth;
      sizes.height = window.innerHeight;

      // 更新相机;
      if (camera) {
        camera.aspect = sizes.width / sizes.height;
        camera.updateProjectionMatrix(); // 修改完相机参数后需要更新一下相机的投影矩阵
      }

      // 更新渲染器
      if (renderer) {
        renderer.setSize(sizes.width, sizes.height);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        renderer.render(scene, camera);
      }
    });

    window.addEventListener("dblclick", () => {
      if (document.fullscreenElement) {
        document.exitFullscreen();
      } else {
        canvas.requestFullscreen();
      }
    });
  };

  const tick = () => {
    control.update();
    renderer.render(scene, camera);
    requestAnimationFrame(tick);
  };

  initCamera();
  initTexture();
  initMesh();
  initScene();
  initRenderer();
  initControl();
  bindListeners();
  tick();
</script>
