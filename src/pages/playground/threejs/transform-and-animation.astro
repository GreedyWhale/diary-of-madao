---
import Layout from "~/layouts/Layout.astro";
import Tips from "~/components/Tips.astro";
---

<Layout>
  <Tips
    title="小提示: "
    content="可画布通过右上角的控件进行调试"
    class="mb-4"
  />

  <div class="transformExample relative mb-4">
    <div class="gui absolute right-0 top-0"></div>
  </div>

  <div class="animationExample"></div>
</Layout>

<script>
  import * as THREE from "three";
  import GUI from "lil-gui";

  const initTransformExample = () => {
    const root = document.querySelector(".transformExample")!;
    const { width } = root.getBoundingClientRect();

    const sizes = {
      width,
      height: 600,
    };

    const scene = new THREE.Scene();
    const geometry = new THREE.BoxGeometry(1, 1, 1).toNonIndexed();
    const vertices = geometry.getAttribute("position");
    const colors = new Float32Array(vertices.count * 3);
    const color = new THREE.Color();
    const colorValues = [
      0xff0000, 0x00ff00, 0x0000ff, 0xffff00, 0x00ffff, 0xff00ff,
    ];

    for (let index = 0; index < 6; index++) {
      color.setHex(colorValues[index]);

      const faceIndex = index * 18;
      // 一个面6个点
      colors[faceIndex] = color.r;
      colors[faceIndex + 1] = color.g;
      colors[faceIndex + 2] = color.b;

      colors[faceIndex + 3] = color.r;
      colors[faceIndex + 4] = color.g;
      colors[faceIndex + 5] = color.b;

      colors[faceIndex + 6] = color.r;
      colors[faceIndex + 7] = color.g;
      colors[faceIndex + 8] = color.b;

      colors[faceIndex + 9] = color.r;
      colors[faceIndex + 10] = color.g;
      colors[faceIndex + 11] = color.b;

      colors[faceIndex + 12] = color.r;
      colors[faceIndex + 13] = color.g;
      colors[faceIndex + 14] = color.b;

      colors[faceIndex + 15] = color.r;
      colors[faceIndex + 16] = color.g;
      colors[faceIndex + 17] = color.b;
    }

    geometry.setAttribute("color", new THREE.BufferAttribute(colors, 3));

    const mesh = new THREE.Mesh(
      geometry,
      new THREE.MeshBasicMaterial({ vertexColors: true }),
    );

    const camera = new THREE.PerspectiveCamera(75, sizes.width / sizes.height);
    camera.position.z = 3;

    const canvas = document.createElement("canvas");
    const renderer = new THREE.WebGLRenderer({ canvas });
    renderer.setSize(sizes.width, sizes.height);

    scene.add(mesh, camera);
    renderer.render(scene, camera);

    const tick = () => {
      renderer.render(scene, camera);
      requestAnimationFrame(tick);
    };

    const initGUI = () => {
      const gui = new GUI({
        container: document.querySelector(".gui") as unknown as HTMLElement,
      });

      const rotationActions = {
        rotationXYZ: () => {
          mesh.rotation.reorder("XYZ");
          mesh.rotation.set(0.5, 0.5, 0.5);
        },
        rotationZYX: () => {
          mesh.rotation.reorder("ZYX");
          mesh.rotation.set(0.5, 0.5, 0.5);
        },
        reset: () => {
          mesh.rotation.reorder("XYZ");
          mesh.rotation.set(0, 0, 0);
        },
      };

      const gimbalLockActions = {
        step1: () => {
          mesh.rotation.reorder("ZYX");
        },
        step2: () => {
          mesh.rotation.z = Math.PI / 3;
        },
        step3: () => {
          mesh.rotation.y = Math.PI / 2;
        },
        step4: () => {
          mesh.rotation.x = Math.PI / 4;
        },
        reset: () => {
          mesh.rotation.reorder("XYZ");
          mesh.rotation.set(0, 0, 0);
        },
      };

      const quaternionActions = {
        step1: () => {
          const eulerZ = new THREE.Euler(0, 0, Math.PI / 3);
          quaternionActions.quaternionZ.setFromEuler(eulerZ);
          mesh.setRotationFromQuaternion(quaternionActions.quaternionZ);
        },
        step2: () => {
          const eulerY = new THREE.Euler(0, Math.PI / 2, 0);
          quaternionActions.quaternionY.setFromEuler(eulerY);
          mesh.setRotationFromQuaternion(
            quaternionActions.quaternionZ.multiply(
              quaternionActions.quaternionY,
            ),
          );
        },
        step3: () => {
          const eulerX = new THREE.Euler(Math.PI / 4, 0, 0);
          quaternionActions.quaternionX.setFromEuler(eulerX);
          mesh.setRotationFromQuaternion(
            quaternionActions.quaternionZ
              .multiply(quaternionActions.quaternionY)
              .multiply(quaternionActions.quaternionX),
          );
        },
        reset: () => {
          const quaternion = new THREE.Quaternion();

          // 将四元数设置为同时绕x轴、y轴和z轴旋转的角度
          const euler = new THREE.Euler(0, 0, 0);
          quaternion.setFromEuler(euler);
          mesh.setRotationFromQuaternion(quaternion);

          quaternionActions.x = 0;
          quaternionActions.y = 0;
          quaternionActions.z = 0;
        },
        updateQuaternion: (axis: "x" | "z") => {
          // 获取物体当前的四元数
          const currentQuaternion = mesh.quaternion.clone();

          // 创建一个新的四元数用于进一步的旋转操作
          const newQuaternion = new THREE.Quaternion();
          // 在这里根据需要动态修改欧拉角
          const euler =
            axis === "x"
              ? new THREE.Euler(quaternionActions.x, 0, 0)
              : new THREE.Euler(0, 0, quaternionActions.z);

          newQuaternion.setFromEuler(euler);
          // 将新的旋转应用到旧的四元数上，得到最终的旋转结果
          currentQuaternion.multiply(newQuaternion);
          currentQuaternion.normalize();

          // 将新的四元数应用到物体上
          mesh.setRotationFromQuaternion(currentQuaternion);
        },

        quaternionX: new THREE.Quaternion(),
        quaternionY: new THREE.Quaternion(),
        quaternionZ: new THREE.Quaternion(),
        x: 0,
        y: 0,
        z: 0,
      };

      const rotationGroup = gui.addFolder("rotation");

      rotationGroup.add(rotationActions, "rotationXYZ").name("旋转顺序 XYZ");
      rotationGroup.add(rotationActions, "rotationZYX").name("旋转顺序 ZYX");
      rotationGroup.add(rotationActions, "reset").name("重置");

      const gimbalLockGroup = gui.addFolder("万向锁");
      gimbalLockGroup
        .add(gimbalLockActions, "step1")
        .name("1. 设置物体的旋转顺序为 ZYX");
      gimbalLockGroup
        .add(gimbalLockActions, "step2")
        .name("2. 围绕 Z 轴旋转 60 度");
      gimbalLockGroup
        .add(gimbalLockActions, "step3")
        .name("3. 围绕 Y 轴旋转 90 度");
      gimbalLockGroup
        .add(gimbalLockActions, "step4")
        .name("4. 围绕 X 轴旋转 45 度");

      gimbalLockGroup
        .add(mesh.rotation, "x")
        .min(-10)
        .max(10)
        .step(0.01)
        .name("5. 围绕 X 轴旋转");
      gimbalLockGroup
        .add(mesh.rotation, "z")
        .min(-10)
        .max(10)
        .step(0.01)
        .name("6. 围绕 Z 轴旋转");

      gimbalLockGroup.add(gimbalLockActions, "reset").name("重置");

      const quaternionGroup = gui.addFolder("四元数");
      quaternionGroup
        .add(quaternionActions, "step1")
        .name("1. 围绕 Z 轴旋转 60 度");
      quaternionGroup
        .add(quaternionActions, "step2")
        .name("2. 围绕 Y 轴旋转 90 度");
      quaternionGroup
        .add(quaternionActions, "step3")
        .name("3. 围绕 X 轴旋转 45 度");

      quaternionGroup
        .add(quaternionActions, "x")
        .min(-10)
        .max(10)
        .step(0.01)
        .onChange(() => {
          quaternionActions.updateQuaternion("x");
        })
        .name("4. 围绕 X 轴旋转");
      quaternionGroup
        .add(quaternionActions, "z")
        .min(-10)
        .max(10)
        .step(0.01)
        .onChange(() => {
          quaternionActions.updateQuaternion("z");
        })
        .name("5. 围绕 Z 轴旋转");

      quaternionGroup.add(quaternionActions, "reset").name("重置");
    };

    root.appendChild(canvas);
    initGUI();
    tick();
  };

  const initAnimationExample = () => {
    const root = document.querySelector(".animationExample")!;
    const { width } = root.getBoundingClientRect();

    const sizes = {
      width,
      height: 600,
    };

    const scene = new THREE.Scene();

    const mesh = new THREE.Mesh(
      new THREE.BoxGeometry(1, 1, 1),
      new THREE.MeshBasicMaterial({ color: 0xffff00 }),
    );

    const camera = new THREE.PerspectiveCamera(75, sizes.width / sizes.height);
    camera.position.z = 5;

    const canvas = document.createElement("canvas");
    const renderer = new THREE.WebGLRenderer({ canvas });
    renderer.setSize(sizes.width, sizes.height);

    scene.add(mesh, camera);
    renderer.render(scene, camera);

    const clock = new THREE.Clock();
    const tick = () => {
      const elapsedTime = clock.getElapsedTime();
      mesh.position.x = Math.cos(elapsedTime);
      mesh.position.y = Math.sin(elapsedTime);

      renderer.render(scene, camera);
      requestAnimationFrame(tick);
    };

    root.appendChild(canvas);
    tick();
  };

  initTransformExample();
  initAnimationExample();
</script>
