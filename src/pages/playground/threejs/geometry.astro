---
import Layout from "~/layouts/Layout.astro";
import Tips from "~/components/Tips.astro";
---

<Layout>
  <Tips
    title="小提示: "
    content="可画布通过右上角的控件进行调试"
    class="mb-4"
  />
  <div class="app relative mb-4">
    <div class="gui absolute right-0 top-0"></div>
  </div>

  <div class="triangle relative mb-4"></div>

  <div class="multipleTriangles relative mb-4">
    <div class="gui-1 absolute right-0 top-0"></div>
  </div>
</Layout>

<script>
  import * as THREE from "three";
  import { OrbitControls } from "three/addons/controls/OrbitControls.js";
  import GUI from "lil-gui";
  import { gsap, Linear } from "gsap";

  const initTriangleGeometryExample = () => {
    const root = document.querySelector(".triangle")!;
    const { width } = root.getBoundingClientRect();

    const sizes = {
      width,
      height: 600,
    };

    const scene = new THREE.Scene();
    // 定义顶点坐标
    const positionsArray = new Float32Array([0, 0, 0, 0, 1, 0, 1, 0, 0]);

    // 将这些坐标变为 Three.js 可以接受的数据格式
    const positionsAttribute = new THREE.BufferAttribute(positionsArray, 3);

    // 创建一个BufferGeometry
    const geometry = new THREE.BufferGeometry();

    // 将顶点的位置信息填充到 BufferGeometry 中
    geometry.setAttribute("position", positionsAttribute);

    // 结合材质组成一个三角形
    const triangle = new THREE.Mesh(
      geometry,
      new THREE.MeshBasicMaterial({
        color: "#F99417",
        wireframe: true,
      }),
    );

    const camera = new THREE.PerspectiveCamera(75, sizes.width / sizes.height);
    camera.position.z = 3;

    const canvas = document.createElement("canvas");
    const renderer = new THREE.WebGLRenderer({ canvas });
    renderer.setSize(sizes.width, sizes.height);

    scene.add(triangle, camera);
    renderer.render(scene, camera);

    const tick = () => {
      renderer.render(scene, camera);
      requestAnimationFrame(tick);
    };

    root.appendChild(canvas);
    tick();
  };

  const initGeometryExample = () => {
    const root = document.querySelector(".app")!;
    const { width } = root.getBoundingClientRect();

    const sizes = {
      width,
      height: 600,
    };

    const scene = new THREE.Scene();
    const geometry = new THREE.BoxGeometry(1, 1, 1);
    const material = new THREE.MeshBasicMaterial({ wireframe: true });
    const mesh = new THREE.Mesh(geometry, material);

    const camera = new THREE.PerspectiveCamera(75, sizes.width / sizes.height);
    camera.position.z = 3;

    const canvas = document.createElement("canvas");
    const renderer = new THREE.WebGLRenderer({ canvas });
    renderer.setSize(sizes.width, sizes.height);

    scene.add(mesh, camera);
    renderer.render(scene, camera);

    const control = new OrbitControls(camera, renderer.domElement);
    control.enableDamping = true;
    control.update();

    const tick = () => {
      control.update();
      renderer.render(scene, camera);
      requestAnimationFrame(tick);
    };

    const initGUI = () => {
      const gui = new GUI({
        container: document.querySelector(".gui") as unknown as HTMLElement,
      });

      const config = {
        segments: {
          width: 1,
          height: 1,
          depth: 1,
        },
      };

      const updateMesh = () => {
        const geometry = new THREE.BoxGeometry(
          1,
          1,
          1,
          config.segments.width,
          config.segments.height,
          config.segments.depth,
        );

        mesh.geometry.dispose();
        mesh.geometry = geometry;
      };

      gui
        .add(config.segments, "width")
        .min(1)
        .onChange(updateMesh)
        .name("widthSegments");

      gui
        .add(config.segments, "height")
        .min(1)
        .onChange(updateMesh)
        .name("heightSegments");

      gui
        .add(config.segments, "depth")
        .min(1)
        .onChange(updateMesh)
        .name("depthSegments");
    };

    root.appendChild(canvas);
    initGUI();
    tick();
  };

  const initMultipleTrianglesExample = () => {
    const root = document.querySelector(".multipleTriangles")!;
    const { width } = root.getBoundingClientRect();

    const sizes = {
      width,
      height: 600,
    };

    const trianglesConfig = {
      counts: 300,
    };

    const scene = new THREE.Scene();

    const getPositionAttribute = (counts: number) => {
      const positionsArray = new Float32Array(counts * 9);
      for (let index = 0; index < positionsArray.length; index++) {
        positionsArray[index] = Math.random() - 0.5;
      }
      // 将这些坐标变为 Three.js 可以接受的数据格式
      const positionsAttribute = new THREE.BufferAttribute(positionsArray, 3);
      return positionsAttribute;
    };

    // 创建一个BufferGeometry
    const geometry = new THREE.BufferGeometry();
    // 将顶点的位置信息填充到 BufferGeometry 中
    geometry.setAttribute(
      "position",
      getPositionAttribute(trianglesConfig.counts),
    );

    // 结合材质组成一个三角形
    const triangles = new THREE.Mesh(
      geometry,
      new THREE.MeshBasicMaterial({
        color: "#F99417",
        wireframe: true,
      }),
    );

    const camera = new THREE.PerspectiveCamera(75, sizes.width / sizes.height);
    camera.position.z = 1;

    const canvas = document.createElement("canvas");
    const renderer = new THREE.WebGLRenderer({ canvas });
    renderer.setSize(sizes.width, sizes.height);

    scene.add(triangles, camera);
    renderer.render(scene, camera);

    const control = new OrbitControls(camera, renderer.domElement);
    control.enableDamping = true;
    control.update();

    gsap.to(triangles.rotation, {
      y: 2 * Math.PI,
      ease: Linear.easeNone,
      duration: 5,
      repeat: -1,
    });

    const initGUI = () => {
      const gui = new GUI({
        container: document.querySelector(".gui-1") as unknown as HTMLElement,
      });

      gui
        .add(trianglesConfig, "counts")
        .min(5)
        .max(300)
        .step(1)
        .onChange(() => {
          // 创建一个BufferGeometry
          const geometry = new THREE.BufferGeometry();
          // 将顶点的位置信息填充到 BufferGeometry 中
          geometry.setAttribute(
            "position",
            getPositionAttribute(trianglesConfig.counts),
          );

          triangles.geometry.dispose();
          triangles.geometry = geometry;
        })
        .name("修改数量");
    };

    const tick = () => {
      control.update();
      renderer.render(scene, camera);
      requestAnimationFrame(tick);
    };

    initGUI();
    root.appendChild(canvas);
    tick();
  };

  initGeometryExample();
  initTriangleGeometryExample();
  initMultipleTrianglesExample();
</script>
