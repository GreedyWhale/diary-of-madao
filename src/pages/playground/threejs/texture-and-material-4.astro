---
import FullScreenCanvas from "~/layouts/FullScreenCanvas.astro";
---

<FullScreenCanvas />

<script>
  import * as THREE from "three";
  import { OrbitControls } from "three/addons/controls/OrbitControls.js";
  import GUI from "lil-gui";

  import colorTexture from "/static/textures/door/Door_Wood_001_basecolor.jpg?url";

  const gui = new GUI();
  const root = document.querySelector(".app")!;
  const canvas = document.createElement("canvas");
  root.appendChild(canvas);

  const sizes = {
    width: window.innerWidth,
    height: window.innerHeight,
  };

  const material = new THREE.MeshBasicMaterial();
  let scene: THREE.Scene;
  let camera: THREE.PerspectiveCamera;
  let renderer: THREE.WebGLRenderer;
  let cube: THREE.Mesh<THREE.BoxGeometry, THREE.MeshBasicMaterial>;
  let sphere: THREE.Mesh<THREE.SphereGeometry, THREE.MeshBasicMaterial>;
  let plane: THREE.Mesh<THREE.PlaneGeometry, THREE.MeshBasicMaterial>;
  let texture: THREE.Texture;
  let control: OrbitControls;

  const initCamera = () => {
    camera = new THREE.PerspectiveCamera(75, sizes.width / sizes.height);
    camera.position.z = 5;
  };

  const initTexture = () => {
    const loader = new THREE.TextureLoader();
    texture = loader.load(colorTexture);
  };

  const initMesh = () => {
    cube = new THREE.Mesh(new THREE.BoxGeometry(1, 1.5, 1), material);
    sphere = new THREE.Mesh(new THREE.SphereGeometry(1), material);
    plane = new THREE.Mesh(new THREE.PlaneGeometry(1, 1), material);

    sphere.position.x = -2;
    plane.position.x = 2;
  };

  const initScene = () => {
    scene = new THREE.Scene();
    scene.add(camera, cube, sphere, plane);
  };

  const initRenderer = () => {
    renderer = new THREE.WebGLRenderer({ canvas });
    renderer.setSize(sizes.width, sizes.height);
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    renderer.render(scene, camera);
  };

  const initControl = () => {
    control = new OrbitControls(camera, renderer.domElement);
    control.enableDamping = true;
    control.update();
  };

  const initGUI = () => {
    const options = {
      color: "#ffffff",
      setTexture: () => {
        material.map = texture;
        material.needsUpdate = true;
      },
      opacity: 1,
      side: "FrontSide",
    };

    gui
      .addColor(options, "color")
      .onChange(() => {
        material.color.set(new THREE.Color(options.color));
      })
      .name("设置颜色");

    gui
      .add(options, "opacity")
      .min(0)
      .max(1)
      .step(0.1)
      .onChange(() => {
        material.transparent = true;
        material.opacity = options.opacity;
        material.needsUpdate = true;
      })
      .name("设置 透明度");

    gui
      .add(options, "side", ["FrontSide", "BackSide", "DoubleSide"])
      .onChange(() => {
        material.side =
          THREE[options.side as "FrontSide" | "BackSide" | "DoubleSide"];
      })
      .name("修改可见面");

    gui.add(material, "wireframe").name("设置 wireframe");
    gui.add(options, "setTexture").name("设置 纹理");
  };

  const bindListeners = () => {
    window.addEventListener("resize", () => {
      sizes.width = window.innerWidth;
      sizes.height = window.innerHeight;

      // 更新相机;
      if (camera) {
        camera.aspect = sizes.width / sizes.height;
        camera.updateProjectionMatrix(); // 修改完相机参数后需要更新一下相机的投影矩阵
      }

      // 更新渲染器
      if (renderer) {
        renderer.setSize(sizes.width, sizes.height);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        renderer.render(scene, camera);
      }
    });

    window.addEventListener("dblclick", () => {
      if (document.fullscreenElement) {
        document.exitFullscreen();
      } else {
        canvas.requestFullscreen();
      }
    });
  };

  const tick = () => {
    control.update();
    renderer.render(scene, camera);
    requestAnimationFrame(tick);
  };

  initCamera();
  initTexture();
  initMesh();
  initScene();
  initRenderer();
  initControl();
  initGUI();
  bindListeners();
  tick();
</script>
